"""Add WikiRevision model and link to WikiPage

Revision ID: 0a3acad3d50a
Revises: ec91920f30ee
Create Date: 2025-04-19 17:19:49.489518

"""
from alembic import op
import sqlalchemy as sa
import datetime


# revision identifiers, used by Alembic.
revision = '0a3acad3d50a'
down_revision = 'ec91920f30ee'
branch_labels = None
depends_on = None


def upgrade():
    # ### Steg 1: Skapa wiki_revision-tabellen (auto-genererat av Alembic) ###
    op.create_table('wiki_revision',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('page_id', sa.Integer(), nullable=False),
        sa.Column('editor_id', sa.Integer(), nullable=True),
        sa.Column('timestamp', sa.DateTime(), nullable=True), # Alembic sätter ofta nullable=True här, men vår modell har default
        sa.Column('title', sa.String(length=100), nullable=False),
        sa.Column('content', sa.Text(), nullable=False),
        sa.Column('comment', sa.String(length=255), nullable=True),
        # Lägg till Foreign Key Constraints HÄR om Alembic inte gjorde det,
        # eller se till att de skapas efter bulk_insert om det krävs.
        # Ofta bäst att definiera dem direkt i create_table om möjligt.
        sa.ForeignKeyConstraint(['editor_id'], ['user.id'], name=op.f('fk_wiki_revision_editor_id_user')),
        sa.ForeignKeyConstraint(['page_id'], ['wiki_page.id'], name=op.f('fk_wiki_revision_page_id_wiki_page')),
        sa.PrimaryKeyConstraint('id', name=op.f('pk_wiki_revision'))
    )
    # Skapa index (auto-genererat av Alembic)
    op.create_index(op.f('ix_wiki_revision_timestamp'), 'wiki_revision', ['timestamp'], unique=False)
    # ### Slut steg 1 ###

    # ### Steg 2: Infoga initiala revisioner (manuellt tillagd kod) ###
    # (Se till att 'sa' är importerat: import sqlalchemy as sa)
    wiki_page_table = sa.table('wiki_page',
        sa.column('id', sa.Integer),
        sa.column('title', sa.String),
        sa.column('content', sa.Text),
        sa.column('editor_id', sa.Integer),
        sa.column('created_at', sa.DateTime)
    )
    wiki_revision_table = sa.table('wiki_revision',
        sa.column('id', sa.Integer),
        sa.column('page_id', sa.Integer),
        sa.column('editor_id', sa.Integer),
        sa.column('timestamp', sa.DateTime),
        sa.column('title', sa.String),
        sa.column('content', sa.Text),
        sa.column('comment', sa.String)
    )

    conn = op.get_bind()
    results = conn.execute(sa.select(
        wiki_page_table.c.id,
        wiki_page_table.c.title,
        wiki_page_table.c.content,
        wiki_page_table.c.editor_id,
        wiki_page_table.c.created_at
    )).fetchall()

    initial_revisions_data = []
    for page_id, title, content, editor_id, created_at in results:
        initial_revisions_data.append({
            'page_id': page_id, 'editor_id': editor_id,
            'timestamp': created_at if created_at else datetime.datetime.utcnow(), # Fallback om created_at är null
            'title': title, 'content': content,
            'comment': 'Initial revision based on existing page'
        })

    if initial_revisions_data:
        op.bulk_insert(wiki_revision_table, initial_revisions_data)
        print(f"Inserted initial revisions for {len(initial_revisions_data)} existing pages.")
    else:
        print("No existing pages found to create initial revisions for.")

    with op.batch_alter_table('user', schema=None) as batch_op:
        batch_op.alter_column('role_id',
               existing_type=sa.INTEGER(),
               nullable=False)

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('user', schema=None) as batch_op:
        batch_op.alter_column('role_id',
               existing_type=sa.INTEGER(),
               nullable=True)

    with op.batch_alter_table('wiki_revision', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_wiki_revision_timestamp'))

    op.drop_table('wiki_revision')
    # ### end Alembic commands ###
